package com.artfara.apps.kipper;

import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.location.Location;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v4.app.ActivityCompat;
import android.support.v4.app.FragmentActivity;
import android.os.Bundle;
import android.support.v4.content.ContextCompat;
import android.util.Log;
import android.widget.Toast;

import com.google.android.gms.common.ConnectionResult;
import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.maps.CameraUpdateFactory;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.OnMapReadyCallback;
import com.google.android.gms.maps.SupportMapFragment;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.MarkerOptions;
import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.ValueEventListener;

public class MapsActivity extends FragmentActivity implements OnMapReadyCallback, GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener {

    private GoogleMap mMap;
    private String mUserName;
    private GoogleApiClient mGoogleApiClient;
    private Location mLocation;
    private DatabaseReference mDatabase;
    private String TAG = " maps class";
    private ValueEventListener mDatabaseChangedListener = new ValueEventListener() {
        @Override
        public void onDataChange(DataSnapshot dataSnapshot) {

            Log.d(TAG, "There are " + dataSnapshot.getChildrenCount() + " users");
            for (DataSnapshot userSnapshot : dataSnapshot.getChildren()) {
                 Latlng location = userSnapshot.getValue(Latlng.class);
                 mMap.addMarker(new MarkerOptions().position(new LatLng(location.latitude, location.longitude)));
                 Log.d(TAG, location.latitude + " - " + location.longitude);
            }
        }

        @Override //autogenerated
        public void onCancelled(DatabaseError databaseError) {
            // Getting Post failed, log a message
            Log.w(TAG, "loadPost:onCancelled", databaseError.toException());
            // ...
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_maps);
        // Obtain the SupportMapFragment and get notified when the map is ready to be used.
        SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager()
                .findFragmentById(R.id.map);
        mapFragment.getMapAsync(this);

        //Load the username from internal storage
        mUserName = getIntent().getStringExtra(Constants.USERNAME_KEY);


        Log.d("android version = ", "" + Build.VERSION.SDK_INT);


        //Check permissions for Android API 22 and up
        if (Build.VERSION.SDK_INT >= 22 && ContextCompat.checkSelfPermission(this,
                Manifest.permission.ACCESS_FINE_LOCATION)
                != PackageManager.PERMISSION_GRANTED) {

            // must request the permission.
            ActivityCompat.requestPermissions(this,
                    new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
                    0);

            // onRequestPermissionsResult() gets the
            // result of the request.

        }

        else {
            //No need to request permissions, start using location
            startUsingLocation();
        }

    }

    //Start location tracking service, and start getting location (to zoom in map)
    public void startUsingLocation(){
        Intent intent = new Intent(this, TrackingService.class);
        startService(intent);

        // Create an instance of GoogleAPIClient.
        if (mGoogleApiClient == null) {
            mGoogleApiClient = new GoogleApiClient.Builder(this)
                    .addConnectionCallbacks(this)
                    .addOnConnectionFailedListener(this)
                    .addApi(LocationServices.API)
                    .build();
        }
        mGoogleApiClient.connect();
    }

    @Override
    public void onRequestPermissionsResult(int requestCode,
                                           String permissions[], int[] grantResults) {

        // If request is cancelled, the result arrays are empty.
        if (grantResults.length > 0
                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {

            // permission was granted, yay!
            //Start tracking users location
            startUsingLocation();


        } else {

            // permission denied, boo!
            //Tell the user that they are a jackass for disabling the permission
            Toast.makeText(this, "App must access location", Toast.LENGTH_LONG);
            finish();
        }
        return;
    }



    /**
     * Manipulates the map once available.
     * This callback is triggered when the map is ready to be used.
     * This is where we can add markers or lines, add listeners or move the camera. In this case,
     * we just add a marker near Sydney, Australia.
     * If Google Play services is not installed on the device, the user will be prompted to install
     * it inside the SupportMapFragment. This method will only be triggered once the user has
     * installed Google Play services and returned to the app.
     */
    @Override
    public void onMapReady(GoogleMap googleMap) {
        mMap = googleMap;


    }


    //Always unregister receivers and unbind service when app is closed out of
    public void onStop(){
        super.onStop();
        stopService(new Intent(this, TrackingService.class));
        mGoogleApiClient.disconnect();
        Log.d(TAG, "stopping service");
    }

    @Override
    public void onConnected(@Nullable Bundle bundle) {
        //Save last known location
        mLocation = LocationServices.FusedLocationApi.getLastLocation(
                mGoogleApiClient);
        if (mMap != null && mLocation != null){
            LatLng location = new LatLng(mLocation.getLatitude(), mLocation.getLongitude());
            mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(location, 14.0f));
            //No need to stay connected, now that we have location
            mGoogleApiClient.disconnect();
            //connect to firebase database and add markers for all connected users
            populateMap();
        }
        else {
            Log.d(TAG, "mMap = " + mMap + " mLocation = " + mLocation);
        }

    }
    //connect to firebase database and add markers for all connected users
    private void populateMap() {
        mDatabase = FirebaseDatabase.getInstance().getReference().child(Constants.USERS_TABLE_NAME);
        mDatabase.addValueEventListener(mDatabaseChangedListener);

    }


    @Override
    public void onConnectionSuspended(int i) {

    }

    @Override
    public void onConnectionFailed(@NonNull ConnectionResult connectionResult) {

    }
}
